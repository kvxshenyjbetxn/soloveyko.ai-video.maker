import os
import subprocess
import re
import datetime
import time

class SubtitleEngine:
    def __init__(self, exe_path=None, model_path=None):
        self.exe_path = exe_path
        self.model_path = model_path

    def generate_ass(self, audio_path, output_path, settings, language='en'):
        engine_type = settings.get('whisper_type', 'amd')
        
        segments = []

        if engine_type == 'standard':
            # --- Standard Python Whisper ---
            print(f"ðŸš€ Running Standard Whisper (Python): Model={self.model_path}, Lang={language}")
            try:
                import whisper
            except ImportError:
                raise ImportError("Library 'openai-whisper' not installed. Run: pip install openai-whisper")

            # Ð—Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÑƒÑ”Ð¼Ð¾ Ð¼Ð¾Ð´ÐµÐ»ÑŒ (Ñ‚ÑƒÑ‚ self.model_path - Ñ†Ðµ Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Ð½Ð°Ð·Ð²Ð°, Ð½Ð°Ð¿Ñ€Ð¸ÐºÐ»Ð°Ð´ 'base')
            model = whisper.load_model(self.model_path)
            
            # Ð¢Ñ€Ð°Ð½ÑÐºÑ€Ð¸Ð±Ð°Ñ†Ñ–Ñ
            result = model.transcribe(audio_path, language=language)
            
            # ÐšÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð°Ñ†Ñ–Ñ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñƒ Ñƒ Ð½Ð°Ñˆ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ñ–Ð²
            for s in result['segments']:
                segments.append({
                    'start': s['start'],
                    'end': s['end'],
                    'text': s['text'].strip()
                })

        else:
            # --- AMD / Fork Whisper (EXE) ---
            if not self.exe_path or not os.path.exists(self.exe_path):
                raise FileNotFoundError(f"Whisper EXE not found: {self.exe_path}")
            if not self.model_path or not os.path.exists(self.model_path):
                raise FileNotFoundError(f"Model file not found: {self.model_path}")

            # Ð’Ð¸Ð´Ð°Ð»ÑÑ”Ð¼Ð¾ ÑÑ‚Ð°Ñ€Ñ– SRT ÑÐºÑ‰Ð¾ Ñ”
            srt_path = os.path.splitext(audio_path)[0] + ".srt"
            if os.path.exists(srt_path):
                os.remove(srt_path)

            cmd = [
                self.exe_path,
                "-m", self.model_path,
                "-f", audio_path,
                "-l", language,
                "-osrt"       
            ]

            startupinfo = subprocess.STARTUPINFO()
            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW

            print(f"ðŸš€ Running Whisper CLI (AMD): {' '.join(cmd)}")
            process = subprocess.run(cmd, startupinfo=startupinfo, capture_output=True, text=True)

            if process.stderr:
                print(f"Whisper Log: {process.stderr[:200]}...")

            # Ð¨ÑƒÐºÐ°Ñ”Ð¼Ð¾ ÑÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð¸Ð¹ SRT
            # CLI Ð·Ð°Ð·Ð²Ð¸Ñ‡Ð°Ð¹ ÑÑ‚Ð²Ð¾Ñ€ÑŽÑ” Ñ„Ð°Ð¹Ð» Ð¿Ð¾Ñ€ÑƒÑ‡ Ð· Ð°ÑƒÐ´Ñ–Ð¾: audio.srt (ÑÐºÑ‰Ð¾ audio.wav) Ð°Ð±Ð¾ audio.wav.srt
            possible_files = [
                audio_path + ".srt",
                os.path.splitext(audio_path)[0] + ".srt"
            ]
            
            found_srt = None
            time.sleep(0.5)
            for p in possible_files:
                if os.path.exists(p):
                    found_srt = p
                    break
            
            if not found_srt:
                 raise Exception(f"SRT file not generated by Whisper CLI.\nStderr: {process.stderr}")

            try:
                segments = self._parse_srt(found_srt)
            finally:
                if os.path.exists(found_srt):
                    os.remove(found_srt)

        # --- Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ñ–Ñ ASS (Ð¡Ð¿Ñ–Ð»ÑŒÐ½Ð° Ð´Ð»Ñ Ð¾Ð±Ð¾Ñ… Ð¼ÐµÑ‚Ð¾Ð´Ñ–Ð²) ---
        if not segments:
            raise Exception("No subtitles generated (segments list empty).")

        processed_segments = self._split_long_lines(segments, settings.get('max_words', 10))
        self._write_ass_file(processed_segments, output_path, settings)

    def _parse_srt(self, filename):
        with open(filename, "r", encoding="utf-8") as f:
            content = f.read()
        
        pattern = re.compile(r'(\d+)\n(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})\n(.*?)(?=\n\n|\Z)', re.DOTALL)
        segments = []
        for match in pattern.finditer(content):
            start_str = match.group(2).replace(',', '.')
            end_str = match.group(3).replace(',', '.')
            text = match.group(4).replace('\n', ' ')
            segments.append({
                'start': self._time_to_seconds(start_str),
                'end': self._time_to_seconds(end_str),
                'text': text.strip()
            })
        return segments

    def _time_to_seconds(self, time_str):
        parts = time_str.split(':')
        h = int(parts[0])
        m = int(parts[1])
        s = float(parts[2])
        return h * 3600 + m * 60 + s

    def _split_long_lines(self, segments, max_words):
        new_segments = []
        for seg in segments:
            words = seg['text'].split()
            if len(words) <= max_words:
                new_segments.append(seg)
                continue
            
            mid = len(words) // 2
            part1_words = words[:mid]
            part2_words = words[mid:]
            
            duration = seg['end'] - seg['start']
            split_time = seg['start'] + (duration / 2)
            
            new_segments.append({'start': seg['start'], 'end': split_time, 'text': " ".join(part1_words)})
            new_segments.append({'start': split_time, 'end': seg['end'], 'text': " ".join(part2_words)})
            
        return new_segments

    def _write_ass_file(self, segments, filename, s):
        r, g, b = s.get('color', (255, 255, 255))
        ass_color = f"&H00{b:02X}{g:02X}{r:02X}"
        fade_in = s.get('fade_in', 0)
        fade_out = s.get('fade_out', 0)
        margin_v = s.get('margin_v', 50)
        font = s.get('font', 'Arial')
        size = s.get('fontsize', 60)

        header = f"""[Script Info]
ScriptType: v4.00+
PlayResX: 1920
PlayResY: 1080

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, OutlineColour, BackColour, Bold, Italic, Alignment, BorderStyle, Outline, Shadow, MarginL, MarginR, MarginV, Encoding
Style: Default,{font},{size},{ass_color},&H00000000,&H80000000,-1,0,2,1,2,0,10,10,{margin_v},1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""
        def format_time(seconds):
            td = datetime.timedelta(seconds=seconds)
            hours, remainder = divmod(td.seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            centiseconds = td.microseconds // 10000
            return f"{hours}:{minutes:02}:{seconds:02}.{centiseconds:02}"

        with open(filename, "w", encoding="utf-8") as f:
            f.write(header)
            for seg in segments:
                start = format_time(seg['start'])
                end = format_time(seg['end'])
                text = seg['text'].strip()
                anim_tag = f"{{\\fad({fade_in},{fade_out})}}" if (fade_in > 0 or fade_out > 0) else ""
                f.write(f"Dialogue: 0,{start},{end},Default,,0,0,0,,{anim_tag}{text}\n")